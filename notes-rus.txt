	Network Simulation Project


Описание :

	Пользователь запускает приложение и видит обычный терминал. Туда можно
	вводить команды. Есть как-бы сервер, на котором можно регистрироваться,
	а потом заходить и выходить оттуда. 
	В дальнейшем, предполагается, в рамках одной сессии (одного запуска), что
	пользователь (возможно, только админ) сможет переключаться между разными
	пользователями, которые	взаимодействуют с сервером одновременно. То есть
	получается такая симуляция многопользовательского взаимодействия, где
	пользователи (как реальный, так и боты) смогут, например, обмениваться
	сообщениями или играть в игру, - и всё это под управлением сервера.
	
	На данный момент реализованы лишь следующие команды:
		- srv register <username>
		- srv login <username>
		- srv logout
	Здесь srv это семейство команд, которое как-бы соответствует работе с
	сервером. Дело в том, что пока сервер один, но потом их может быть
	несколько и они могут различаться по предоставляемым ими сервисам. Поэтому
	серверы вполне могут иметь свои названия и свои наборы команд, через
	которые клиент с ними взаимодействует. Это, например, как система git имеет
	много разных команд: git add, git add, git commit и т.д. Так же и здесь.
	В этом базовом наборе команд не хватает 'srv signout', которая удаляла бы
	пользователя. Таким образом, одна из первых целей это реализовать все эти
	четыре команды.
	Вместе с этим предстоит рефакторинг и реализация нескольких других целей,
	как по интерфейсу, так и по внутреннему функционалу.
	А после этого можно будет переходить к реализации механизма, позволяющего
	как-бы "пристыковывать" другое приложение к нашей клиент-серверной схеме,
	чтобы это другое приложение (например, игра) запускалось в нашем терминале
	и работало в многопользовательском режиме через сервер.


	  Итак, на дворе 18.03.25. Ещё раз подумаем о том, что мы хотим от этого
	приложения.
	
	  Главные компоненты проекта:
	  	- terminal window
	  	- server
	  	- CLI client
	  	- dispatcher
	  	- simulation
	
	  У приложения один пользователь. Он открывает терминал и вводит команды.
	Можно зайти на сервер командой 'srv login'. Теперь можно пользоваться
	службами сервера srv. Пользователь может открыть второй терминал (рядом с
	первым) и в нём зайти на сервер под другим логином. Таким образом, окно
	приложения будет разбито на 2, 3 или 4 терминала, каждый из которых
	управляется пользователем приложения.
	  Представим, что сервер предоставляет полезные для пользователя сервисы,
	службы. Это может быть, например, обмен сообщениями или игра. Пользователь
	получает эти услуги посредством "общения" с сервером, вводя необходимые
	команды. Так вот, с технической точки зрения, пользователь отправляет
	серверу запросы (request) и получает от сервера ответы (response).
	  Как раз этим и занимается client. Это специальный объект, который:
	  
				- привязан к терминальному окну;
				- получает пользовательский ввод;
				- обрабатывает этот ввод;
				- формирует объект request'а;
				- отправляет этот request на сервер;
				- и наконец, ждёт ответа от сервера в виде response'а.
	
	  Но всё же не совсем так. Клиент не общается с сервером напрямую. И сервер
	не посылает свои response'ы напрямую клиентам. Между сервером и клиентами
	есть диспетчер. Он принимает и хранит request'ы от клиентов и response'ы от
	сервера. То есть диспетчер это просто хранилище этих объектов. Что-то вроде
	почтового отделения. Но клиенты сами забирают предназначенные им response'ы,
	а сервер сам забирает свои request'ы. Например, сервер, с технической точки
	зрения, работает в отдельном потоке исполнения (отличном от потока окна
	приложения) и "слушает" диспетчер на предмет наличия там request'ов, и, если
	они там есть, забирает себе очередной request и обрабатывает (handle) его.
	  Предполагается, что в рантайме, вместе с пользователем самого приложения,
	присутствуют псевдоюзеры, боты, которые могут, например, отправлять и
	принимать сообщения и участвовать в играх. За управление этими фальшивыми
	пользователями отвечает модуль simulation.
	  
	  Что именно делает client?
	Мы хотим чтобы client отвечал за две вещи:
	
				1) обработка пользовательского ввода;
				2) "прослушивание" сервера (на самом деле, диспетчера);
				
	  Но дело в том, что эти две вещи конфликтуют во времени. А именно, пока
	пользователь что-то вводит в терминал, в это время сервер может "прислать"
	сообщение от другого пользователя (от бота), которое необходимо вывести на
	экран терминала. И пока пользователь ждёт ответа от сервера на свою команду
	или пользователь уже находится "в игре", было бы неуместно в этот момент
	увидеть вдруг сообщение или приглашение в другую игру. Впрочем, это может
	зависеть от самой пользовательской команды, от её интерфейса, от того
	сколько "тактов общения" с сервером она требует и т.д.
	  Кстати, в случае с графическим клиентом (GUI client) этой проблемы можно
	избежать: пока пользователь изменяет что-то в одном элементе окна, другой
	элемент окна может спокойно принимать сообщения. То есть у GUI client'а есть
	несколько каналов общения в обоих направлениях: приёма и отправки
	чего-либо. Чего не скажешь про CLI (command line interface) client: он в
	этом ограничен, у терминала есть только одно место, куда пользователь что-то
	вводит и откуда он что-то читает.
	  Вариант решения этой проблемы "наложения" функций клиента: когда начинает
	обрабатываться очередной пользовательский ввод, можно вначале блокировать
	распечатку в терминал всякого рода сообщений сервера, не связанных с текущим
	вводом, с текущим сеансом "общения" пользователя с сервером. Пусть, пока
	пользователь "общается" с сервером, эти сообщения и результаты обработки
	других response'ов накапливаются в некотором буфере. По окончании текущего
	сеанса "общения", блокировка снимается и все накопившиеся за это время
	сообщения появляются на экране терминала.
	
	  Какие потоки исполнения мы имеем в процессе работы приложения?	  			
  			- поток окна приложения. Это главный поток, который не должен
  			прерываться ничем другим чтобы окно не зависало;
  			- поток сервера. В этом потоке сервер слушает диспетчер. Здесь
  			сервер спрашивает у диспетчера "У тебя есть request'ы от
  			пользователей сети?". Если request есть, то сервер забирает его
  			себе на обработку, а если нет, то чуть-чуть спит и спрашивает
  			снова;
  			- поток ботов. Все боты будут "общаться" с сервером в отдельном
  			потоке, причём одном на всех. Создавать отдельный поток для
  			каждого бота слишком жирно;
  			- поток всех клиентов, которых "создал" пользователь приложения
  			в данный момент. Для каждого открытого терминала будет создан
  			свой client и добавлен в список клиентов. Все клиенты этого
  			списка будут слушать сервер в этом отдельном потоке. Этому
  			потоку необходимо взаимодействовать с потоком окна приложения.
  			Но как это будет происходить до конца непонятно.
	

Конкретные Цели :
	- Реализовать следующие базовые команды:
		- srv register <username>
		- srv login <username>
		- srv logout
		- srv signout
